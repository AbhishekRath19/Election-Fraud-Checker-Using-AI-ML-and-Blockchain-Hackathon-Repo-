// SPDX-License-Identifier: MIT  // License to keep it open-source for the hackathon
pragma solidity ^0.8.20;         // Modern compiler with built-in overflow checks

import "@openzeppelin/contracts/access/Ownable.sol";  // Ownership control (onlyOwner)

/// @title Encrypted, one-vote-per-voter ballot box
/// @notice Stores encrypted ballots + commitments; prevents double voting via nullifier hash
contract Election is Ownable { // Ownable lets an authority manage lifecycle

    struct Ballot {
        bytes32 commitment;     // keccak256(candidateId || salt) to later prove correctness
        bytes ciphertext;       // Off-chain encrypted payload (e.g., NaCl sealed box)
        address sender;         // EOA that submitted (not identity)
        uint256 timestamp;      // When it was recorded
    } // Struct holding a single encrypted ballot

    // ===== Storage =====
    mapping(bytes32 => bool) public nullifierUsed; // one-vote-per-voter: hashed voter token
    Ballot[] public ballots;                       // append-only list of ballots
    bool public votingOpen = true;                 // simple lifecycle flag

    // ===== Events =====
    event BallotSubmitted(
        uint256 indexed index,    // position in ballots[]
        bytes32 indexed commitment,
        bytes32 indexed nullifierHash,
        address sender,
        uint256 timestamp
    ); // Emitted on successful vote

    event VotingPaused(bool isOpen); // Emitted when owner pauses/resumes voting

    // ===== Modifiers =====
    modifier whenVotingOpen() {
        require(votingOpen, "Voting is closed");   // Prevent submissions if closed
        _;
    } // Lifecycle guard

    /// @notice Owner can open/close voting (e.g., start/end of demo window)
    function setVotingOpen(bool isOpen) external onlyOwner {
        votingOpen = isOpen;                       // Flip the flag
        emit VotingPaused(isOpen);                 // Notify indexers/UIs
    } // Admin lifecycle control

    /// @notice Submit one encrypted ballot
    /// @param nullifierHash hash of (opaqueVoterId || serverSalt) computed off-chain
    /// @param commitment keccak256(candidateId || salt) commitment to the choice
    /// @param ciphertext encrypted payload (authority can decrypt later)
    function submitBallot(
        bytes32 nullifierHash,                     // Prevents double voting
        bytes32 commitment,                        // Auditable commitment
        bytes calldata ciphertext                  // Sealed vote data
    ) external whenVotingOpen {
        require(!nullifierUsed[nullifierHash], "Already voted"); // One vote per nullifier
        require(ciphertext.length > 0, "Empty ciphertext");      // Basic sanity check

        nullifierUsed[nullifierHash] = true;       // Burn the nullifier to block re-use

        ballots.push(Ballot({
            commitment: commitment,                // Store commitment for audits
            ciphertext: ciphertext,                // Store encrypted vote
            sender: msg.sender,                    // Keep sender for rate-limit/analysis
            timestamp: block.timestamp             // On-chain time
        })); // Persist ballot data

        emit BallotSubmitted(                      // Emit event for UI/scan/QR
            ballots.length - 1,
            commitment,
            nullifierHash,
            msg.sender,
            block.timestamp
        ); // Event is the main indexing surface
    } // Main entry to cast a vote

    /// @notice Returns number of ballots recorded (for UI pagination)
    function ballotCount() external view returns (uint256) {
        return ballots.length;                     // Length of ballots array
    } // Simple getter

    /// @notice Read a ballot by index (ciphertext remains opaque)
    function getBallot(uint256 index)
        external
        view
        returns (bytes32 commitment, bytes memory ciphertext, address sender, uint256 timestamp)
    {
        Ballot storage b = ballots[index];         // Load from storage
        return (b.commitment, b.ciphertext, b.sender, b.timestamp); // Return tuple
    } // Public readonly accessor
}
